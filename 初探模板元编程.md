## 模板元编程是什么？

如果你在搜索引擎中搜索模板元编程，你可能会遇到一些奇奇怪怪的词语，黑魔法，噬魂怪之类的，但单其实模板元编程并没有那么神秘。C++er都知道，C++代码分为编译期间和运行期间，其中很多代码在编译期间就已经执行了，比如在某个项目中，你需要定义一个全局常量
```c++
const int LENGHT = 100;
```
对于LENGHT这个常量的值，编译器在编译期间便可以确定他的值，同样的，如果你写下了类似下面不是很主流的代码
```c++
const int HEIGHT = 5 * 6;
```
对于HEIGHT来说是个常量，编译器需要在编译期间就需要确定他的值，所以编译器就需要在编译期间计算5*6的值，也就是说，这段代码会在编译期间执行。从这里我们可以看出，编译器不仅仅是把代码转化为可执行的机器代码，而是可以做其他一些事情的，当有人发现这些情况后，做出更多的尝试时，发现编译器其实可以做更多的事情。尤其在设计模板相关的代码时，程序员惊奇的发现，编译器可以做如此多的事情，于是把这些发现系统化，并进一优化扩展，形成了一步完整的图灵机————模板元编程。<sup><引1></sup>

## 最简单的例子

为了简单起见，先用一段最简单的代码来演示模板元编程，改代码改编（简化）自Erwin Unruh于1994年展示的代码，该段代码被认为第一段模板元编程的代码
```c++
template <int i> 
struct D {
    D(void*){};   //注释1
};

template<int X , int Y> 
void sumInt();

template<int X , int Y>
void sumInt(){
    const int v = X + Y;   //注释2
    D<v> d(1);   //注释3
}

int main(){
    sumInt<2,6>();  //注释4
}
```
+ 注释1 定义了一个模板结构，构造函数时一个void*,这个结构的作用就是让程序在编译阶段就出错。

+ 注释2 这里int v是个常量，所以编译器需要在编译期间就确定他的值

+ 注释3 这行代码有2个比较关键的地方，第一个时结构D的模板参数，使用了v这个常量，这是合法的代码，第二个时结构D的构造参数，要求类型是void*,而代码传入了一个int,所以会出错，无法通过编译

+ 注释4 调用函数，用于计算2+6的结果，你也可以换成其他的值来测试下

然后编译这段代码时，理所当然的无法完成编译，下面是我的用gcc7.3.0编译这段代码时的输出
```shell
E:\template\Count> g++ .\main.cpp -o count
.\main.cpp: In instantiation of 'void sumInt() [with int X = 2; int Y = 6]':
.\main.cpp:16:17:   required from here
.\main.cpp:12:10: error: invalid conversion from 'int' to 'void*' [-fpermissive]
     D<v> d(1);
          ^
.\main.cpp:3:5: note:   initializing argument 1 of 'D<i>::D(void*) [with int i = 8]'
     D(void*){};
     ^
E:\template\Count>
```
而我用vs2019编译的时候程序同样报错，错误信息显示为
```shell
错误	C2664	 “D<8>::D(D<8> &&)”: 无法将参数 1 从“int”转换为“void *”	count E:\Template\Count\main.cpp	12	
```
不同的编译器打印的错误信息虽然有所不同，但都可以这这些信息中找到2+6的结果，不同的编译器的输出信息有所不同，但都可以从中找出2+6的计算结果。


## 类型识别

上面给出了一个简单的例子，演示了通过编译器计算加法，这个例子可以演示什么是模板元编程，但没有什么实际的意义，毕竟计算加法完全没必要搞的这么复杂。任何一项技术，只有能解决实际的问题，才能称为有用。所以，接下来看一下模板元编程在实际编程中的解决什么样的问题。

对于一个很简单的函数
```c++
void cout_int(const int& v) {
	std::cout << "这是一个int" << v << std::endl;
}

//调用如下
double a = 14.55;
cout_int(a);
```
这段代码可以顺利编译并运行，使用VS2019编译器编译运行这段代码，输出结果位14，编译器甚至没有给出任何警告消息。解决方案有两个，一个是写一篇文档，在文档中说明传入的参数必须是int,然后祈祷用户仔细阅读这篇文档并且在使用代码时，时刻牢记这里只能传入一个int，但这种做法是对服务器友好-用户警惕（server-friendly,client-beware）的解决方案。<sup>引2<suo>。

另一个方案就是在函数内进行判断，传入的参数类型是否是int,如果不是int可以给出相关信息或者让编译器在在编译阶段就报错。那这里就引发一个问题，如何判断传入的参数类型呢？为此，就需要用到模板元编程了。
```c++
//使用模板特例化来区别基本类型
template<typename T>
class DataType {
public:
	static const bool is_int = false;
	static const bool is_double = false;
	static const bool is_char = false;
    static const bool unknow = true;
    
};
/*首先声明一个模板类，这个类没有声明类通常的构造，析构等函数，因为用不到，类只有三个公
有静态常量，是因为这段示例代码之用于区分int,double和char三种类型，如果需要区分其他类
型，稍后可以看到可以简单的修改即可*/

template<>
class DataType<int> {
public:
	static const bool is_int = true;
	static const bool is_double = false;
	static const bool is_char = false;
};
/*这个类声明是DataType的模板特例化，也就是说在调用DataType类时，编译器需要根据代码来
选择究竟选择那个模板，如果编译器选择了int的模板特例化，那DataType的静态公有常量is_int
的值就为true.而如果选择其他的模板特例化或者没有使用特例化，则is_int则为false,下面
double,char同理*/

/*另一个需要注意的地方是所有的特例化模板都没有unknow这个常量，也就是说如果编译器选择模
板时，没有对应的特例化模板，就直接选择原始的DataType模板，这个技巧可以用于处理未知类型
的情况*/

template<>
class DataType<double> {
public:
	static const bool is_int = false;
	static const bool is_double = true;
	static const bool is_char = false;
};


template<>
class DataType<char> {
public:
	static const bool is_int = false;
	static const bool is_double = false;
	static const bool is_char = true;
};
```
接下来需要通过一个函数来实现类型的区分
```c++
enum TypeNu {
	UNKONW = 0,
	INT = 1,
	DOUBLE = 2,
	CHAR = 3
};

template<typename T>
TypeNu data_diff(const T& val) {
	TypeNu res = UNKONW;
    if (DataType<T>::unknow) return res;
    /*如果类型T不属于int，double和char,那编译器不会选择特例化模板，这里可以判断类型T
	是否属于限定的范围*/

	if (DataType<T>::is_int)
		res = INT;
    /*传入的参数T类型如果是int,那编译器在编译期间就会确定使用DataType的int特例化,这
	样就能判断传入的参数类型是否是int,下面的double和char同理*/    
	else if (DataType<T>::is_double)
		res = DOUBLE;
	else if (DataType<T>::is_char)
		res = CHAR;
	return res;
}
```
上面的代码演示了如何通过编译器来确定类型是int,double还是char,稍加扩展就可以区分全部的C++内建类型，回到最初的问题，函数只要修改为
```c++
void cout_int(const int& v) {
    if(data_diff(v) != INT){
        std::cout<<"传入参数类型错误，无法处理";
        return;
    }
	std::cout << "这是一个int" << v << std::endl;
}
```

## 使用标签参数以及移除if语句

模板元编程的一个很重要的功能就是输出一个类的类型，略有有区别于前面介绍的类型的识别，通过这项技术，可以将代码中很多if语句移除，本质上来说，通过这项技术可以将运行期间if的判断移动到编译期间判断，进而减少运行期间的开销。

在正式介绍之前，我需要非常郑重的说明下，这项技术可以移除很多if语句，但并非让你把整个工程里全部的if语句移除掉，即使实际情况确实可以做到完全移除，但你需要慎重考虑对工程做出这么大的改动是否合适。


引1：More Effective C++:55 Specific Ways To Improve You Programme And Designs,Third Edition

引2：C++ Primer Plus,Sixth Edition
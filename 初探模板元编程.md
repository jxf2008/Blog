## 模板元编程是什么？

如果你在搜索引擎中搜索模板元编程，你可能会遇到一些奇奇怪怪的词语，黑魔法，噬魂怪之类的，但单其实模板元编程并没有那么神秘。C++er都知道，C++代码分为编译期间和运行期间，其中很多代码在编译期间就已经执行了，比如在某个项目中，你需要定义一个全局常量
```c++
const int LENGHT = 100;
```
对于LENGHT这个常量的值，编译器在编译期间便可以确定他的值，同样的，如果你写下了类似下面不是很主流的代码
```c++
const int HEIGHT = 5 * 6;
```
对于HEIGHT来说是个常量，编译器需要在编译期间就需要确定他的值，所以编译器就需要在编译期间计算5*6的值，也就是说，这段代码会在编译期间执行。从这里我们可以看出，编译器不仅仅是把代码转化为可执行的机器代码，而是可以做其他一些事情的，当有人发现这些情况后，做出更多的尝试时，发现编译器其实可以做更多的事情。尤其在设计模板相关的代码时，程序员惊奇的发现，编译器可以做如此多的事情，于是把这些发现系统化，并进一优化扩展，形成了一步完整的图灵机————模板元编程。

没错，模板元编程时被发现的，而不是被发明的.<sup><引1></sup>

## 最简单的例子

为了简单起见，先用一段最简单的代码来演示模板元编程，改代码改编（简化）自Erwin Unruh于1994年展示的代码，该段代码被认为第一段模板元编程的代码
```c++
template <int i> 
struct D {
    D(void*){};   //注释1
};

template<int X , int Y> 
void sumInt();

template<int X , int Y>
void sumInt(){
    const int v = X + Y;   //注释2
    D<v> d(1);   //注释3
}

int main(){
    sumInt<2,6>();  //注释4
}
```
+ 注释1 定义了一个模板结构，构造函数时一个void*,这个结构的作用就是让程序在编译阶段就出错。

+ 注释2 这里int v是个常量，所以编译器需要在编译期间就确定他的值

+ 注释3 这行代码有2个比较关键的地方，第一个时结构D的模板参数，使用了v这个常量，这是合法的代码，第二个时结构D的构造参数，要求类型是void*,而代码传入了一个int,所以会出错，无法通过编译

+ 注释4 调用函数，用于计算2+6的结果，你也可以换成其他的值来测试下

然后编译这段代码时，理所当然的无法完成编译，下面是我的用gcc7.3.0编译这段代码时的输出
```shell
E:\template\Count> g++ .\main.cpp -o count
.\main.cpp: In instantiation of 'void sumInt() [with int X = 2; int Y = 6]':
.\main.cpp:16:17:   required from here
.\main.cpp:12:10: error: invalid conversion from 'int' to 'void*' [-fpermissive]
     D<v> d(1);
          ^
.\main.cpp:3:5: note:   initializing argument 1 of 'D<i>::D(void*) [with int i = 8]'
     D(void*){};
     ^
E:\template\Count>
```
而我用vs2019编译的时候程序同样报错，错误信息显示为
```shell
错误	C2664	 “D<8>::D(D<8> &&)”: 无法将参数 1 从“int”转换为“void *”	count E:\Template\Count\main.cpp	12	
```
不同的编译器打印的错误信息虽然有所不同，但都可以这这些信息中找到2+6的结果，不同的编译器的输出信息有所不同，但都可以从中找出2+6的计算结果。


## 模板元编程曾经做过什么


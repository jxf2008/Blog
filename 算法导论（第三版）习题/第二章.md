## 2-1-1

A[6] = {31，41，59，26，41，58}
1. 将key=41和前面面的数对比，因为31小于key，最后数组顺序不变，依然为{31，41，59，26，41，58}
2. 将key=59和前面的数对比，因41小于key，最后数组顺序不变，依然为{31，41，59，26，41，58}
3. 将key=26和前面的数对比，因59大于key，将key和59互换，数组变为{31，41，26(key)，59，41，58},将key继续和前面的数字比较，如果满足<font color=green>前面的数字大于key</font>，则将前面的数字可key交换，直到<font color=red>key位于数组最前端</font>或者<font color=red>前面的数字小于key</font>,最后数组为{26(key)，31，41，59，41，58}
4. 将key=41和前面的数对比，因59大于key，将key和59互换，根据步骤3的交换原则，数组最后为{26,31,41,41,59,58}
5. 将key=58和前面的数对比，因59大于key，将key和59互换，数组为{26,31,41,41,58,59}

## 2-1-2
C++实现
```c++
const int Len = 6;
int A[Len] = {1,8,5,3,9,3};


for(int i = 1 ; i < Len ; ++i){
    for(int j = i-1 ; j >= 0 ; --j){
	    if(A[j+1]  > A[j]){
		    int tmp = A[j+1];
		    A[j+1] = A[j];
		    A[j] = tmp;
	    }else
		    break;
	}
}
```
伪代码实现
```python
for i = 1 to A.size() - 1
    for j = i-1 to 0
        if A[j+1] <= A[j]
            break
        if A[j+1] > A[j]
            A[j+1] <-> A[j]
```

## 2-1-3

伪代码实现
```python
u = X  #X为任意输入值
result = null
for i = 0 to A.size() - 1
    if A[i] == u
        result = A[i]
        break
```
说实话，我不是很清楚这条题目到底是什么意思。。。

## 2-1-4

数组A和B的元素个数均为n,而目标数组C元素个数为n+1,数组C种全部元素均为0
1. 将A[n-1]和B[n-1]和C[n]相加。令k=n
2. 判断C[k]是否大于1，如果大于1，将C[k-1]和(C[k]-2)相加，并将C[k]置为C[k]-2
3. --k,然后重复步骤2，直到C[k-1]小于或等于1，或者k=0
4. --n,重复步骤1-3,直到n=0

伪代码实现
```python
for n = A.size() - 1 to 0
    C[n+1] = A[n] + B[n] + A[n+1]
    k = n+1
    while k>=0 && C[k]>1  #步骤3的判断
        C[k-1] = C[k-1] + (C[k]-2) 
        C[k] = C[k] - 2
        --k
```
在图像处理中，很多时候需要处理的图像中的一个部分，并不需要在乎该部分的细节，而是需要知道该部分的大致轮廓。比如通用的手势“OK”，如果一张图片上，有个人举着手比划“OK”的手势，如果需要识别图中人物的手势，这个时候比较其轮廓是一个比较可行的方法，因为每个人的手都会有很多细节差别，这会给对比造成很多困难，相反如果只是比较手部的外部轮廓，事情就会简单许多。因此在opencv中，提供了很多与轮廓相关的功能。

## 查找与绘制轮廓

对于查找和绘制轮廓，opencv提供了两个函数分别对应这两个功能
```c++
//查找轮廓
void findContours( InputArray image, 
                   OutputArrayOfArrays contours,
                   int mode, 
                   int method, 
                   Point offset = Point());
```
参数image是查找轮廓的目标图片，该图片必须是8位单通道的图片，并且以及二值化，因为在处理图片的轮廓时，只需要图片内各部分的边界信息，而对于其内部信息没有价值，因此在查找前需要把图片转换位8位单通道图片，另外需要注意的是这个参数并不是const

参数contours是查找的全部边界，该参数类型是OutputArrayOfArrays，但一般都会传入一个
```c++
vector<vecotr<Point>>
```
其中vector[i]表示第i条轮廓，而vector[i][n]则表示第i条轮廓中的第n个点，对于opencv中轮廓用诺干个点（也就是cv::Point）来表示

参数mode用于设置查找轮廓的方式，目前有4种方式

RETR_EXTERNAL：只查找外部轮廓

RETR_LIST：查找全部轮廓

RETR_CCOMP：查找全部轮廓，并把他们组织成双层结构

RETR_TREE：查找全部轮廓，并重新建立网状结构

查找轮廓函数可以查找图片的全部轮廓，这些轮廓都是以多维数组的形式储存的，而opencv为了比较直观的显示这些轮廓，提供了一个轮廓绘制函数
```c++
void drawContours(InputOutputArray image, 
                    InputArrayOfArrays contours,
                    int contourIdx, 
                    const Scalar& color,
                    int thickness = 1, int lineType = LINE_8,
                    InputArray hierarchy = noArray(),
                    int maxLevel = INT_MAX, 
                    Point offset = Point() );
```
参数image是用于绘制轮廓的图片

参数contours就是findContours()函数的查询结果

参数contourIdx用于设置绘制轮廓的数量，既绘制contours{contourIdx}，如果该值为负数，则绘制全部轮廓

参数color，thickness,lineType用于指定绘制轮廓线条的颜色，宽度和类型，一般使用默认值

这两个函数使用相对简单，这里通过一个简单的示例来演示下
```c++
cv::Mat mat_src = cv::imread("E:/HY.png");

cv::Mat mat_dst,mat_draw,mat_draw_longest;
std::vector<std::vector<cv::Point>> contours;

//把png图片转换为单通道图片，并且二值化
cv::cvtColor(mat_src, mat_dst, cv::COLOR_BGR2GRAY);
cv::threshold(mat_dst, mat_dst, 100, 255, cv::THRESH_BINARY);

//查找全部轮廓
cv::findContours(mat_dst, contours, cv::RETR_LIST,cv::CHAIN_APPROX_NONE);

std::cout << "轮廓数量为：" << contours.size() << std::endl;

//在另一张相同大小的图片上绘制出全部轮廓
mat_draw = cv::Mat::zeros(mat_src.size(), CV_8UC1);
cv::drawContours(mat_draw, contours, -1 ,cv::Scalar(255));
```
运行结果如下

![图1](https://jxf2008-1302581379.cos.ap-nanjing.myqcloud.com/github_blog/opencv/contour_1.png)

注意我在程序里面打印了查找轮廓的数量，一共有552条，而且图片在二值化处理时忽略了小于100的元素，如果二值化的时候取更大范围或者更复杂的图片，轮廓的数量会更多，因此在实际运用中直接查询图片轮廓的操作并不多

## 几何特征

对于图片中某些物体，如果需要对其进行识别，需要知晓其轮廓，而其中先要确定是物体的范围，如果把物体所在范围确定了，就可以排除很多的干扰。对于图片中某个物体，如果知晓了该物体的边界上的多个点（也就是该物体的轮廓），那就可以确定该物体在图片中的区域，也就是说可以排除图片的其他区域，这样对进一步分析图片非常有用。

opencv提供了若干个函数来帮助确定物体（轮廓）所在的最小区域，如果该区域是矩形，那该矩形可能不是水平的，因此opencv提供了一个类用于表示该区域
```c++
class RotatedRect{
public:
    Point2f center;
    Size2f size;
    float angle;
};
```
下面几个函数是opencv提供的最小区域查询函数，输入轮廓，便可以知道该轮廓（表示的物体）所在的最小区域
```c++
RotatedRect minAreaRect( InputArray points );
RotatedRect fitEllipse( InputArray points );
void minEnclosingCircle( InputArray points,
                        CV_OUT Point2f& center, 
                        CV_OUT float& radius );
```

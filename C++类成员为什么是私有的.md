首先说明下，在c++标准中，类成员变量可以有3个关键词，public,protected,private,分别对应公有成员，保护成员，私有成员。换句话说，c++标准是完全允许使用公有成员的，所以我写这篇文章的目的是说明我个人不用protected或public成员的原因，并不代表你（或其他人)不可以用

**事实上，我绝对不会反对你将类成员设为公有，因为那和我没关系。。**

开始整体

## 第一步
对于一个类的定义
```c++
class Human_protected{
protected:
    double Age;
    std::string nm;
public:
    void GetName(std::string NewName){nm = NewName;}
};
```
他还有另一个“写法”
```c++
class Human_private{
private:
    double Age;
    std::string nm;
public:
    std::string GetName()const{return nm;}
    double GetAge()const{return Age;}
    void GetName(std::string NewName){nm = NewName}； 
};
```
这两个类将会作为基类，而他们类成员的值需要在继承类中使用，于是一个类将他的成员设为protected，以方便继承他的类的使用，而另一个类更侧重封装，将类成员设为私有，如需使用他们的值则需要调用类成员函数

先看下两者的区别，以便让你有充足的理由选择其中的某一个.目前为止双方的优势为
>class　Human_protected
1. 少打了不少字母，同时少定义两个成员函数
>class Human_private
暂无。。。

目前看来，class　Human_protected暂时优势，所以你选择了他，也就是选择将成员变量设为protected。Let's Continue..

## 第二步

在c++中，继承是个很常用的概念，对于第一步中的两个Human类，通过继承来建立一个Worker类是个不错的主意
```c++
class Worker_protected:public Human_protected{
private:
    double Pay;  //工资
    std::string TechType;  //技术工种名称
public:
    void ShowInfo()const;
};
```
他的另一种“写法”其实完全一样
```c++
class Worker_private:public Human_private{
private:
    double Pay;
    std::string TechTypeSchool;
public:
    void ShowInfo()const;
};
```

他们的不同在于成员函数ShowInfo()函数，他们的代码有所不同
```c++
void Worker_protected::ShowInfo()const{
    std::cout<<"Name:"<<nm<<std::endl;
    std::cout<<"Age:"<<Age<<std::endl;
    std::cout<<"Technology Name :"<<TechType<<std::endl;
}

//----------------------
void Student_private::ShowInfo()const{
    std::cout<<"Name:"<<GetName()<<std::endl;  //区别
    std::cout<<"Age:"<<GetAge()<<std::endl;  //区别
    std::cout<<"Technology Name :"<<TechType<<std::endl;
}
```
这里的区别在于，对于protected成员nm和Age，继承他的类可以直接在成员函数中调用，而对于私有成员，继承他的类要使用他们的值必须使用基类的成员函数.我们再次统计两个继承类的优劣势
>Human_protected
1. 成员函数中不需要调用基类的成员函数就可以直接使用基类的成员变量，节约的调用基类成员函数的开支，同时再次少打了一些字母。不要忽略多打字母的劣势，这有时候会让人感到厌烦甚至出错(这也是C++11引入关键字auto的原因之一）
>Human_private

暂无

这里protected再次取胜,不过实际的软件设计往往会比较复杂，所以我们继续

## 第三步
对于一个表示工人（worker)的类来说，他需要的功能远远不止显示信息（ShowInfo()函数）怎么多，我们需要加入更多的函数来完善这个类
```c++
void GetInfo(const std::string& NM , int ages , const std::string& techtype) //录入信息
void CountPay(int Hours);  //计算工资，小时数*工资数 +工种工资，不同的共种待遇不同
void ShowPay()const; //显示格式 （张三 ：2000元）
void ShowHoliday(int Hours)const; //显示格式 （李四：已用年假5小时）
//。
//。
//。
//。
```
以上成员函数实现Worker类的功能，包括录入信息，计算，显示工人的工资，显示他已经请的年假，等等，这些函数都除CountPay()外，都使用到了基类的成员变量nm（姓名）.当然这些对于一个Worker类任然不够，我们假设还有其他10个成员函数（其实还是不够，但已经足够说明我们今天需要讨论的问题）来实现Worker类。这些函数都有一个共同特点，他们需要使用到基类的成员变量nm,调用方式第二步已经说明了。

现在protected和private的优劣势越发明显，随着继承类（需要使用基类成员变量的）成员函数增多，private需要调用跟多次的函数，写更多的字母。。

**似乎胜负已分，那让我们再次继续。**

## 第四步
软件设计中途遇到设计上的变化是很稀松平常的事，一个软件在设计周期内经常需要改动其设计，而这次促使你修改软件的原因是你的老板跑过来找你，要求把姓名改用编号，老板这么要求的原因有两个
1. 很多员工抱怨显示名字有侵犯隐私的嫌疑

2. 工人的姓名有相同的，财务根据姓名支付薪水的时候把钱打进了错误的人的账号里（真希望我的银行账号也有这样幸运的一天。。。。）

据此，你的老板要求你用一个六位编号（数字）来代替姓名，因为每个工厂里的每个工人入职是都会分配一个唯一的六位编号,不用担心重复以及隐私的问题

对于Worker_private类来说，你可以把基类Human_private中的成员变量std::string nm直接注释掉（不注释也许，反正留着也不会造成什么影响)，然后增加一个新的类变量int number,在GetName()中把新变量number转换成int即可

即把函数
```c++
std::string getName()const{
    return nm;
}
```
转换为
```c++
std::string getName()const{
    return std::to_string(number);
}
```
就可以了，你根本不用考虑继承他的类，继承他的类都调用getName()函数获得一个string,继承他的所有类（包含所有的子子孙孙）都不要为此做任何修改,然后当你再次编译运行程序时，你发现程序里所有员工的姓名都变成了一串数字。

然后我们来看Human_protected类，他同样需要修改，你第一个想到的办法可能是和上面Human_private类一样，增加一个int Number类成员。但不同于Human_private,Human_protected类在里的成员nm处理就会比较棘手，首先，你可以不删除这个已经废弃的变量，但如果不删除这个成员变量，你无法确定继承该类的类会不会使用到该成员变量，也就是说，只要不删除改变量，你程序编译运行后，你的程序某个位置任然可能直接显示员工的姓名若不是编号，这就可能导致泄露隐私的问题，要知道在今天，泄露员工隐私可是个大问题。。。。。作为一名严谨的程序员，未了程序的安全可靠性，你在做这样的修改后把这个程序其他的代码全部都检查了一遍。。。。

当然，你也可以选择直接注释掉已经废弃的成员变量nm，结果。。。
```c++
std::cout<<nm;
```
这样的代码，直接删除类成员变量nm，整个程序里只要用到nm变量的地方，就会导致程序崩溃。最后解决的方案和不删除一样————检测整个程序！！！。

当然，你也可以有另一种该法，即把std::string nm 直接改成int nm;这样变量名不变对于类似
```c++
std::cout<<nm;
```
的代码，他可以继续正常执行（有原来的输出string变成输出int),但对于
```c++
std::string Info = nm + TechType;
```
这样的代码，，直接修改变量类型依然会出错。所有的情况，最后的解决办法是一样的，那就是你必须检查所有继承类的代码，以确保修改基类后，这些继承类任然能正确的执行他们的功能

>结论：对于类成员未protected的基类的类成员的修改结果就是你必须检查整个程序以确保修改后的正确性。

当然对于我现在写的例子来说这没什么，毕竟这只有几行代码，但如果你的项目比较大呢？现在你有没有隐隐约约的意识到一些问题？

## 第五步
我们继续设计软件，实际工作中的软件设计规模往往比较大，而聪明的你满腹才华你不再满足在一家工厂拿着5K的月薪，为一个老板编写工人管理系统，你觉得自立门户自主创业，经过几年的努力，你已经是一位软件公司的BOSS，拥有50个员工，现在你接到一笔价值一亿美元的软件生意，软件是帮助客户定做一套企业管理软件，你和客户商量花费三年实际来完成，两年半时间完成，半年时间测试

这个软件拥有三千万行的代码，大约包含了1500个类，其中有一个基类human类，他有一个成员变量std::string name，整个程序有大约1000个类直接或间接继承自这个类，大约有12000个类成员函数都需要使用到这个类的成员变量std::string Name。为了少打一些字母，你的程序员把std::string Name设为protected。

两年多过去了，你公司的软件即将完成并准备展开为期半年的测试，这时候你的客户打电话过来，要求把姓名改为用编号（一个七位数，类型必须是long long)直接原因是你客户的直接竞争对手在怂恿工人去控告公司侵犯隐私，

另外，软件的起始设计开始于两年前，硬件的变化也促使客户要求改用编号(long long),因为这款软件需要和其他软/硬件对接。

最后，公司人员的增加使得员工重名的几率增大，工资发错人之类的现象不时出现

由于std::string Name涉及了1000多个类和其中大约12000个成员函数，所以你要把这些全部逐一检查，修改（必须怎么做的原因就和第四步所说的一样）。当然，你还必须在几个月内完成软件剩余部分的同时完成这些工作（实时上需要修改的代码占了已完成部分的大多数）。。。。。你尝试在上一步中的方法，直接用替换，但是的程序员告诉你，无法保证修改后程序还能正确的执行，用为很多地方有std::string Name和另一个std::string相加的代码,但你的程序员很难准确的记住所有，毕竟人类的记忆很难记住如此庞大的代码。。

现在你面临着到时间不能完成而支付巨额违约金的问题，或者你先发制人去控告客户提出了合同外的要求，但眼下最重要的问题在于你的一亿美元很有可能拿不到了，而这两年公司的开支都依赖银行贷款。。。。

回过来想想，相比于这些问题，最初将变量设为private,然后修改对应的成员函数（具体方法见第四步）是不是就不会遇到这些麻烦了，最后我们比较下多打几个字母是不是会更容易些。。。。

## 第六步

**书接上回！！！**

最终，你赢得了和你客户的官司，由于你客户提出了合同外的要求，所以你不需要支付违约金，但客户显然也不愿意支付你一亿美元的合同款，于是你和你的客户再次陷入漫长的官司中，当然我们先撇开法律问题不谈，眼下你最重要的是找到资金支付员工工资，维持公司的正常运营，这公司毕竟是你一手创建的心血。

而你手里有一个现成的C++类库可以对外出售，毕竟你原来的客户已经不愿为这个程序支付一毛钱。

对于第三方的C++类库，市场上有很多，图像库Qt,微软的MFC图形库，甚至Boost库，你迫切的希望把你的类库出售，让尽可能多的人来购买你的拷贝。为此，你为你的C++类库写了一份说明文档，这份文档和我们常见的文档有所不同，他比较厚。。。。

之所以比较厚，原因在于上面有一份关键词列表，上面也许有五万甚至十万个关键词，你告诉你（潜在的）客户，这些关键字以后的版本有可能会被删除，如果其中有个变量被删除了，请检查整个程序，确保和该变量有关的代码都已经做了相应的修改。。。。。。

**你有没有担心过被人打死在当场？**

而如果你的变量是private的，那问题就简单多了，因为当某个类的某个变量被删除时，客户无论如何使用该变量，都是通过某个成员函数来调用的，因此你可以把该函数稍加修改
```c++
int getPrintID()const{
    //return p_ID;
    return 1;
}
```      
然后你在你更新类库的文档加上这么一句，“原先的接口(getPrintID())已被声明废弃，但仍保留其接口（值固定为1）用作和以前的代码兼容，但会在将来的某个时间移除。”

这句话是不是很熟悉？相信你以前看文档的时候，如果有版本升级，那肯定会见到类似的话，没错啦，其实这句话翻译过来就是，”变量我删了，你如果还用这个变量的话他是个固定的值，我代码里原来用到的地方我以后会逐一修改，但目前没时间，具体修改完成是在将来的某个时间。。。。“


## 第七步

假设你的公司是一家极具韧性的公司，你的员工在你的带领下客服了第六步我所述的困难，而且你也找到了一个优质客户，他也不再现在你终于有了第一个客户，一切想着好的方向在发展

你的类库中的一个类，其中有个变量这个表示某个硬件设备的可设置功率，最大为9，最小为0（即关闭状态）；
```c++
class EnginePro{
protected:
    int devicePower;
}
```
当然，如果设为private的，则有必须使用一个专用的接口（成员函数）
```c++
class EnginePri{
private:
    int devicePower
public:
    int setDevicePower(int p){if(p >= 10) return;devicePower = p}
}
```
你的客户在购买了你的类库后使用（继承）了这个类，他需要在这个了类的基础上增加一些额外的功能。而硬件厂商在产品说明书上强调了，功率不能超过9，否则肯能对硬件造成损伤。

但是。。。。，

**你永远不可能确定你的客户会做什么？**

在设备运行的某个步骤中，需要把功率设为1，于是有类似下面的代码
```c++
enginer6.devicePower = 11;
```
不要怀疑，这是很容易犯的错误，然后你的客户打电话告诉你，你的类库存在着严重的bug，还损坏了昂贵的设备，并且要求退款甚至赔偿损失。。。你会不会感到很无辜。



呼~~~~经过这么多步，我们回到最初的问题，你的类成员是选择private还是protected，或者干脆是public呢？

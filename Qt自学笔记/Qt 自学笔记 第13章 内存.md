## new与delete

熟悉c++的小伙伴们对new非常敏感，的确c/c++中内存管理是个非常棘手的问题，但是Qt自学笔记写到现在，似乎只有new，没有delete，到现在为止类的析构函数都没见过，那程序的内存泄露该怎么办呢？在第一章的Hello Qt演示程序中，我们演示会导致内存泄露的代码，那后面的ReadTxt有内存泄露吗？答案是否定的，除非你在main()函数里生成对象使用了new，否则整个程序不会出现内存泄露的问题。

这时候很多人就会感到奇怪，ReadTxt构造函数里那么多new，但连个析构函数都没写，怎么可能没有内存泄露呢？主要原因在于Qt使用了一套自由的内存管理机制，大部分时候使得我们可以不用自己管理内存的问题。为了演示这个问题，先来看一个程序
```c++
#include <QApplication>
#include <QLabel>
#include <QHBoxLayout>

int main(int argc , char** argv)
{
	QApplication app(argc , argv);
	QWidget* parent_Widget = new QWidget;
	QLabel* child1_Label = new QLabel("Child1");
	QLabel* child2_Label = new QLabel("Child2");
	
	QHBoxLayout* main_Layout = new QHBoxLayout;
	main_Layout->addWidget(child1_Label);
	main_Layout->addWidget(child2_Label);
	parent_Widget->setLayout(main_Layout);
	
	parent_Widget->show();
	app.exec();

    delete child1_Label;
    delete child2_Label;
    delete parent_Widget;

	return 0;
}
```

这段代码非常简单，在一个QWidget上通过布局管理器安装了2个QLabel,这和第一章，第二章的示例代码很相似，不同的是在添加了3个delete来避免内存泄漏，当用户关闭窗体后，代码就会执行那些delete的代码向操作系统返回申请的内存。编译运行这段代码，一切都OK。然后把这段代码做些小小的改动，既把那3个delete的顺序改下
```c++
    delete parent_Widget;
    delete child1_Label;
    delete child2_Label;
```
从C++的角度来看这样的改动没什么影响，当我们再次编译运行程序的时候，此时的确一切正常，但如果关闭窗体的话，程序就会直接崩溃，QtCreator会直接报错

```c++
Error - RtlWerpReportException failed with status code :-1073741823. Will try to launch the process directly
13:28:31: 程序异常结束。
13:28:31: The process was ended forcefully.
13:28:31: E:/QtExe/build-QtLayout-Desktop_Qt_5_12_3_MinGW_64_bit-Debug/debug/QtLayout.exe crashed.
```
报错的内容根据不同的操作系统和编译器略有不同，示例程序可能会卡死，你可能需要使用操作系统的终止键来强行关闭该程序。。

**那么问题出在哪里呢？**

## 父/子对象

问题的根源出在Qt自带的内存对象管理机制上，前面多次提到父对象，子对象的概念，以上面的示例代码为例，两个QLabel通过布局管理器安装到一个QWidget上，那child1_Label和child2_Label就成为了parent_Widget的子对象，Qt的(直接或间接继承自QObjct)类中，会维护一个列表，该列表记录着全部的子对象，
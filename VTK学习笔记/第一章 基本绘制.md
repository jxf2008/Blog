## 基本模型的绘制

对于VTK学习的第一步，是进行最基本的一些模型的绘制，通过这些了解VTK是如何工作的。首先是一段生成圆形的代码
```c++
int main(int, char* []){
	vtkNew<vtkNamedColors> colors;

	//创建圆形
	vtkNew<vtkRegularPolygonSource> polygonSource;
	polygonSource->GeneratePolygonOff();
	polygonSource->SetNumberOfSides(50);
	polygonSource->SetRadius(5);
	polygonSource->SetCenter(0, 0, 0);

	//窗体显示
	vtkNew<vtkPolyDataMapper> mapper;
	mapper->SetInputConnection(polygonSource->GetOutputPort());

	vtkNew<vtkActor> actor;
	actor->SetMapper(mapper);

	vtkNew<vtkRenderer> renderer;
	renderer->AddActor(actor);
	renderer->SetBackground(colors->GetColor3d("DarkGreen").GetData());

	vtkNew<vtkRenderWindow> renderWindow;
	renderWindow->AddRenderer(renderer);

	vtkNew<vtkRenderWindowInteractor> renderWindowInteractor;
	renderWindowInteractor->SetRenderWindow(renderWindow);

	renderWindow->SetWindowName("Circle");
	renderWindow->Render();
	renderWindowInteractor->Start();

	return EXIT_SUCCESS;
}
```

上面这段代码复制自VTK的官方示例，这段代码大致可以分为两个部分，创建圆形模型和显示。VTK和很多C++的第三方类库一样，使用了自己设计的内存管理方式，以避免用户使用C++原生的new和delete。vtkNew类就是内存管理的核心，大多数VTK的对象都可以使用vtkNew类生成而不用考虑释放内存，这些申请和释放内存的工作有vtkNew来自动完成，可以将vtkNew类理解为VTK为自己的类设计的一个专有的智能指针。

vtkRegularPolygonSource类用于提供多边形相关的功能，GeneratePolygonOff()函数用于设置该模型多边形还是一个多边框，可以注释掉该函数看下区别。比较有趣的是SetNumberOfSides()函数，如果不调用该函数，那多边形的默认值是6，下面是效果对比图，从对比图可以看出，VTK把圆形当场一个多边形来处理，只不过这个多边形的边比较多。

![](https://jxf2008-1302581379.cos.ap-nanjing.myqcloud.com/github_blog/VTK1-1.png)

注释掉SetNumberOfSides()后，默认边数为6
![](https://jxf2008-1302581379.cos.ap-nanjing.myqcloud.com/github_blog/VTK1-2.png)

示例代码的另一个部分是显示相关的代码，这里使用了VTK自带的界面相关的类，通常来说，在实际使用中，一般不会使用VTK的界面功能（稍后会介绍如何在Qt中使用VTK），因为VTK是专精三维模型而不是GUI界面。这里简单的介绍下窗体界面，在介绍Qt和VTK混合编程前，会暂时跳过窗体相关的代码，因为这部分代码大多数是一样的。

## 线段绘制正方体

前面的示例中vtkRegularPolygonSource类的GeneratePolygonOff()函数用户控制模型创建的时候是以实体还是线段的形式。在很多模型中，只需要框架而不需要实体，这种情况下一种简单的方法就是利用线段来绘制，比如创建一个正方形
```c++
#include <vtkActor.h>
#include <vtkCellArray.h>
#include <vtkCellData.h>
#include <vtkLine.h>
#include <vtkNamedColors.h>
#include <vtkNew.h>
#include <vtkPoints.h>
#include <vtkPolyData.h>
#include <vtkPolyDataMapper.h>
#include <vtkProperty.h>
#include <vtkRenderWindow.h>
#include <vtkRenderWindowInteractor.h>
#include <vtkRenderer.h>
#include <vtkUnsignedCharArray.h>

#ifdef vtkGenericDataArray_h
#define InsertNextTupleValue InsertNextTypedTuple
#endif

#include "vtkAutoInit.h"
VTK_MODULE_INIT(vtkRenderingOpenGL2)
VTK_MODULE_INIT(vtkInteractionStyle)
VTK_MODULE_INIT(vtkRenderingFreeType)

int main(int, char* []){
    vtkNew<vtkPolyData> linesPolyData;

    //创建点，一个正方形需要四条线段，共有四个点
    double p0[3] = { 0.0, 0.0, 0.0 };
    double p1[3] = { 0.0, 1.0, 0.0 };
    double p2[3] = { 1.0, 1.0, 0.0 };
    double p3[3] = { 1.0, 0.0, 0.0 };

    //vtkPoints类用于存放需要用到的点
    vtkNew<vtkPoints> pts;
    pts->InsertNextPoint(p0);
    pts->InsertNextPoint(p1);
    pts->InsertNextPoint(p2);
    pts->InsertNextPoint(p3);

    linesPolyData->SetPoints(pts);  //注释1

	//设置四条线段
    vtkNew<vtkLine> line0;
    line0->GetPointIds()->SetId(0, 0);
    line0->GetPointIds()->SetId(1, 1);
    vtkNew<vtkLine> line1;
    line1->GetPointIds()->SetId(0, 1);
    line1->GetPointIds()->SetId(1, 2);
    vtkNew<vtkLine> line2;
    line2->GetPointIds()->SetId(0, 2);
    line2->GetPointIds()->SetId(1, 3);
    vtkNew<vtkLine> line3;
    line3->GetPointIds()->SetId(0, 3);
    line3->GetPointIds()->SetId(1, 0);

    vtkNew<vtkCellArray> lines;
    lines->InsertNextCell(line0);
    lines->InsertNextCell(line1);
    lines->InsertNextCell(line2);
    lines->InsertNextCell(line3);

    linesPolyData->SetLines(lines); //注释2

    vtkNew<vtkNamedColors> namedColors;

    //设置线段的颜色
    vtkNew<vtkUnsignedCharArray> colors;
    colors->SetNumberOfComponents(3);
    colors->InsertNextTupleValue(namedColors->GetColor3ub("Red").GetData());
    colors->InsertNextTupleValue(namedColors->GetColor3ub("Yellow").GetData());
    colors->InsertNextTupleValue(namedColors->GetColor3ub("Green").GetData());
    colors->InsertNextTupleValue(namedColors->GetColor3ub("White").GetData());

    linesPolyData->GetCellData()->SetScalars(colors);  //注释3

    //窗体显示
    vtkNew<vtkPolyDataMapper> mapper;
    mapper->SetInputData(linesPolyData);

    vtkNew<vtkActor> actor;
    actor->SetMapper(mapper);
    actor->GetProperty()->SetLineWidth(4);

    vtkNew<vtkRenderer> renderer;
    renderer->AddActor(actor);
    renderer->SetBackground(namedColors->GetColor3d("SlateGray").GetData());

    vtkNew<vtkRenderWindow> window;
    window->SetWindowName("Colored Lines");
    window->AddRenderer(renderer);

    vtkNew<vtkRenderWindowInteractor> interactor;
    interactor->SetRenderWindow(window);

    window->Render();
    interactor->Start();

    return EXIT_SUCCESS;
}
```
首先，VTK需要提供全部的点，绘制一个四边形，移动需要四个点，这些点创建后先存放在vtkPoints类对象中。然后在把vtkPoints类对象放入一个vtkPolyData类对象中。

vtkPolyData类是VTK中一个用于处理数据对象的类，通常用于创建点，线，多边形，三角形等这些二维以内的数据。在创建了四个点后，将这些点先放入一个vtkPoints类对象中中，然后同伙通过vtkPolyData类的SetPoints()函数放入vtkPolyData类对象中。

在下一步创建线的代码里，可以看出VTK设计人员的惊世智慧。通常来说，任何计算机语言在绘制一条线段时，需要提供两个点的坐标，VTK同样如此。TVK中使用vtkLine来表示一个线段，需要使用该类的setID()函数来指定线段的两个点，每一个vtkLine都调用了两次该函数，该函数的第一个参数表示vtkLine的点的索引，即0表示这是第一个点，1表示这是第二个点；而第二个参数表示vtkPolyData类对象中的点索引，vtkLine可以根据该索引从vtkPolyData类对象中获得对应的值


在颜色设置的部分，使用了vtkNamedColor和vtkUnsignedCharArray共同来进行颜色的设置，其中vtkNamedColor用于创建各种颜色，该类可以根据参数来生成VTK内部的颜色数据，即用户只需要提供对应的颜色名称（使用vtkStdString表示），该类就可以生成TVK的颜色数据，比如参数使用了“Red”，用户无需知道“Red”在VTK内部如何表示的，该类的GetData()函数即可生成VTK内部表示红色的数据；vtkUnsignedCharArray类则用于储存多个颜色相关的数据。

通过注释1，2和3可以看出，VTK的把数据设置完成后，放入vtkPolyData类对象中。

总结下：基本逻辑就是，先确定点，通常使用一个double数组来表示，然后多个点都放入vtkPoints；然后确定线，每条线都是一个vtkLine，然后全部线都放入vtkCellArray；最后vtkPoints和vtkCellArray都要放入vtkPolyData中，并且在确定线之前，vtkPoints就必须先放入。

最后有关窗体显示的部分就暂时跳过，这部分到和Qt混合编程时再详细介绍。

代码运行如下图

![](https://jxf2008-1302581379.cos.ap-nanjing.myqcloud.com/github_blog/VTK1-3.png)

如果你不嫌麻烦的话，很多不需要实体的模型都可以通过这种方式来绘制。

![](https://jxf2008-1302581379.cos.ap-nanjing.myqcloud.com/github_blog/VTK1-4.png)


## 绘制立方体

之前的示例显示了用线段进行模型的创建，但使用VTK的时候，使用线段创建模型的需求并不多，大部分需要创建一个实体模型。

在之前的示例里，用线段创建模型的基本步骤是先确定点，再根据点确定线，而创建立方体的基本思路是一致的。首先一个立方体包含8个点，再确定了这8个点后，可以根据每四个点确定一个面的原则来确定全部6个面，这样一个立方体的元素就全部确定下来了

```c++
int main(int, char* []){
    vtkNew<vtkPolyData> cube;

    vtkNew<vtkNamedColors> colors;

    //首先确定立方体的8个点
    double p0[3] = { 0.0, 0.0, 0.0 };
    double p1[3] = { 1.0, 0.0, 0.0 };
    double p2[3] = { 1.0, 1.0, 0.0 };
    double p3[3] = { 0.0, 1.0, 0.0 };
    double p4[3] = { 0.0, 0.0, 1.0 };
    double p5[3] = { 1.0, 0.0, 1.0 };
    double p6[3] = { 1.0, 1.0, 1.0 };
    double p7[3] = { 0.0, 1.0, 1.0 };
    vtkNew<vtkPoints> allPoints;
    allPoints->InsertNextPoint(p0);
    allPoints->InsertNextPoint(p1);
    allPoints->InsertNextPoint(p2);
    allPoints->InsertNextPoint(p3);
    allPoints->InsertNextPoint(p4);
    allPoints->InsertNextPoint(p5);
    allPoints->InsertNextPoint(p6);
    allPoints->InsertNextPoint(p7);
    cube->SetPoints(allPoints);

    // 根据每四个点确定一个面,这里每个数组的元素，是point在vtkPolyData里的索引
    vtkIdType s0[4] = { 0, 3, 2, 1 };
    vtkIdType s1[4] = { 4, 5, 6, 7 };
    vtkIdType s2[4] = { 0, 1, 5, 4 };
    vtkIdType s3[4] = { 1, 2, 6, 5 };
    vtkIdType s4[4] = { 2, 3, 7, 6 };
    vtkIdType s5[4] = { 3, 0, 4, 7 };

    //这里使用vtkCellArray来表示一个面的数据
    vtkNew<vtkCellArray> allSides;

    //将6个面的数据放入vtkPolyData里，由于每个面都是一个数组
    //因此插入函数的第一个参数是数组的有效值的个数
    allSides->InsertNextCell(vtkIdType(4), s0);
    allSides->InsertNextCell(vtkIdType(4), s1);
    allSides->InsertNextCell(vtkIdType(4), s2);
    allSides->InsertNextCell(vtkIdType(4), s3);
    allSides->InsertNextCell(vtkIdType(4), s4);
    allSides->InsertNextCell(vtkIdType(4), s5);
    cube->SetPolys(allSides);

    //设置颜色
    vtkNew<vtkFloatArray> scalars;

    //这里设置每个点的颜色，这样每个面都可以看成一个坐标轴
    //而面中的任意一个点都会根据坐标轴所在的位置，获得一个值
    //这个值就是该点的颜色
    scalars->InsertTuple1(0, 0);
    scalars->InsertTuple1(1, 1);
    scalars->InsertTuple1(2, 2);
    scalars->InsertTuple1(3, 3);
    scalars->InsertTuple1(4, 4);
    scalars->InsertTuple1(5, 5);
    scalars->InsertTuple1(6, 6);
    scalars->InsertTuple1(7, 7);
    cube->GetPointData()->SetScalars(scalars);


    //窗体创建和显示，先跳过
    vtkNew<vtkPolyDataMapper> cubeMapper;
    cubeMapper->SetInputData(cube);
    cubeMapper->SetScalarRange(cube->GetScalarRange());
    vtkNew<vtkActor> cubeActor;
    cubeActor->SetMapper(cubeMapper);

    vtkNew<vtkCamera> camera;
    camera->SetPosition(1, 1, 1);
    camera->SetFocalPoint(0, 0, 0);

    vtkNew<vtkRenderer> renderer;
    vtkNew<vtkRenderWindow> renWin;
    renWin->AddRenderer(renderer);
    renWin->SetWindowName("Cube");

    vtkNew<vtkRenderWindowInteractor> iren;
    iren->SetRenderWindow(renWin);

    renderer->AddActor(cubeActor);
    renderer->SetActiveCamera(camera);
    renderer->ResetCamera();
    renderer->SetBackground(colors->GetColor3d("Cornsilk").GetData());

    renWin->SetSize(600, 600);

    renWin->Render();
    iren->Start();

    return EXIT_SUCCESS;
}
```
运行结果

![](https://jxf2008-1302581379.cos.ap-nanjing.myqcloud.com/github_blog/VTK1-5.png)

前面的示例，无论用于表示点，还是线段，或者面，数据都是使用数组的形式，之所以使用数组是可以更加直观的展示数据之间的对应关系，一般来说现代C++代码都避免直接使用数组这种源自C语言的数据结构，在vtk的官方示例中，更多的是采用STL的容器或其他一些数据结构，比如vtk官方示例中，创建点和面使用了std::array类
```c++
  vtkNew<vtkNamedColors> colors;

  std::array<std::array<double, 3>, 8> pts = {{{{0, 0, 0}},
                                               {{1, 0, 0}},
                                               {{1, 1, 0}},
                                               {{0, 1, 0}},
                                               {{0, 0, 1}},
                                               {{1, 0, 1}},
                                               {{1, 1, 1}},
                                               {{0, 1, 1}}}};
  // The ordering of the corner points on each face.
  std::array<std::array<vtkIdType, 4>, 6> ordering = {{{{0, 3, 2, 1}},
                                                       {{4, 5, 6, 7}},
                                                       {{0, 1, 5, 4}},
                                                       {{1, 2, 6, 5}},
                                                       {{2, 3, 7, 6}},
                                                       {{3, 0, 4, 7}}}};

  // We'll create the building blocks of polydata including data attributes.
  vtkNew<vtkPolyData> cube;
  vtkNew<vtkPoints> points;
  vtkNew<vtkCellArray> polys;
  vtkNew<vtkFloatArray> scalars;

  // Load the point, cell, and data attributes.
  for (auto i = 0ul; i < pts.size(); ++i)
  {
    points->InsertPoint(i, pts[i].data());
    scalars->InsertTuple1(i, i);
  }
  for (auto&& i : ordering)
  {
    polys->InsertNextCell(vtkIdType(i.size()), i.data());
  }

  // We now assign the pieces to the vtkPolyData.
  cube->SetPoints(points);
  cube->SetPolys(polys);
  cube->GetPointData()->SetScalars(scalars);
```
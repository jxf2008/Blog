## vtkCommand

在三维制图的运用中，经常需要使用一些动画效果，比如前一章绘制的立方体模型，有时候就需要让模型旋转，类似下面这样

![](https://jxf2008-1302581379.cos.ap-nanjing.myqcloud.com/github_blog/VTK2-1.gif)

对于这方面的需求VTK提供了多种解决方案，使用观察者/回调模式就是其中一个非常常见的解决方案，而这个模式的核心就是vtkCommand类。vtkCommand可以监控数十种event，这些event的枚举值和代表的含义可以查询VTK文档中vtkComman类的说明

![](https://jxf2008-1302581379.cos.ap-nanjing.myqcloud.com/github_blog/VTK2-2.png)

要实现模型的选择，需要用到vtkCommand::TimerEvent，而vtkCommand是一个抽象类，但使用却非常简单，要使得立方体旋转，就需要继承vtkCommand类，实现一个专门用于“观察”vtkCommand::TimerEvent的类

```c++
class CubeCmd : public vtkCommand {
private:
    vtkActor* actor = nullptr;
public:
    CubeCmd() = default;
    ~CubeCmd() = default;
    void SetActor(vtkActor* act) { actor = act; }

    virtual void Execute(vtkObject* caller, unsigned long eventId, void* vtkNotUsed(callData))override;
    static CubeCmd* New() { return new CubeCmd(); }
};
```
首先是一个不太常用的静态函数New()，之前提到VTK自带了一套内存管理系统，生成对象是通常使用vtkNew类而不是c++自带的new，而且VTK中所有直接或间接继承子vtkObjectBase类都可以使用该内存系统；从另一个角度来说，一个直接或间接继承自vtkObjectBase类的自定义类，如果需要使用VTK自带的内存管理系统，则必须按照VTK的方式来创建对象。具体的来说，就是类定义一个静态函数New()来生成对象，而VTK的内存管理系统会调用该函数并加入其内存管理中

然后便是vtkCommand的核心函数Execute()，该函数是一个纯虚函数，因此继承的类必须重新实现该函数，该函数有三个参数

1. caller，调用vtkCommand的对象
2. eventId，这个是事件的ID
3. callData，一个void*指针，一般用于回调函数，不过有场景会用到

然后是该函数的实现
```c++
void CubeCmd::Execute(vtkObject* caller, unsigned long eventId, void* vtkNotUsed(callData)) {
    //首先判断是否是时间事件
    if (vtkCommand::TimerEvent == eventId) {
        //每次时间事件触发，就旋转5度，这里是按照Y轴旋转
        //RotateY()，RotateY()函数则可以按照X和Z轴旋转
        actor->RotateY(5);
        //每次需要刷新下，即重新呈现
        static_cast<vtkRenderWindowInteractor*>(caller)->Render();
    }
}
```
该函数的实现也非常简单，该函数在某个事件触发时会被调用，在函数内需要判断下是否是对应的事件，如果是，那就做想要的操作。在本例中就判断触发的事件是否为vtkCommand::TimerEvent，如果是，则将vtkActor旋转5度。

然后是CubeCmd的使用代码，可以和前一章Cube的代码坐标比较
```c++
vtkNew<vtkRenderer> renderer;
vtkNew<vtkRenderWindow> renWin;
renWin->AddRenderer(renderer);
renWin->SetWindowName("Cube");

vtkNew<vtkRenderWindowInteractor> iren;
iren->SetRenderWindow(renWin);

renderer->AddActor(cubeActor);
renderer->SetActiveCamera(camera);
renderer->ResetCamera();
renderer->SetBackground(colors->GetColor3d("Cornsilk").GetData());
renWin->SetSize(600, 600);
renWin->Render();

//变化
iren->Initialize();

vtkNew<CubeCmd> cubeCmd;
cubeCmd->SetActor(cubeActor);

//设置观察者，该函数第一个参数是观察者需要观察的具体事件
iren->AddObserver(vtkCommand::TimerEvent, cubeCmd);

//创建一个触发器，该触发器每100毫秒会触发一次，也就是会触发vtkCommand::TimerEvent
iren->CreateRepeatingTimer(100);

iren->Start();
```

## 摄像机

在上一个示例中，由于需要模型绕着一个轴旋转，这导致模型的一部分无法显示，而在VTK的运用中，经常会遇到模型移动的情况。可以通过调整vtkCamera相关功能来修复这个问题。

在VTK中，之前显示模型的功能，有用到vtkCamera，该类用于设置显示区域等相关的属性。该类的工作模式类似下图

![](https://jxf2008-1302581379.cos.ap-nanjing.myqcloud.com/github_blog/VTK2-3.png)

SetFocalPoint()函数用于设置相机的焦点。

SetViewAngle()函数用于设置摄像机的投影角度，默认是30度，而camera->SetPosition(double x , double y , double z)，函数则用于设置摄像机和焦点的位置。因此前一个示例中显示区域过小导致部分模型无法显示的问题，可以通过扩大摄像机的投影角度，或者增加摄像机和焦点的距离。不过一般情况下会选择增加摄像机和焦点的距离，因为扩大摄像机的投影角度（角度比较大的情况下）有可能会导致模型失真

摄像机还有个重要功能是投影的角度，简单的来说，将摄像机放在焦点的哪一个轴上，可以通过SetViewUp(double x , double y , double z)来设置摄像机的位置（即摄像机位于哪一个轴上），摄像机默认位于y轴上，即默认为SetViewUp(0, 1, 0)；

## 自定义动画

之前的示例演示了如何通过继承vtkCommand类，通过观察者模式来实现动画效果，但实际运用时，可能会遇到一些比较复杂的运动控制，比如下面这个模型，在绕着一个点选择，旋转到一半后模型的颜色需要切换。对于这种要求比较特殊的情况，vtk自带的运动相关功能可能无法满足，这里就需要自定义运动

![](https://jxf2008-1302581379.cos.ap-nanjing.myqcloud.com/github_blog/VTK2-4.gif)
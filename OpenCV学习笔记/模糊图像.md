很多时候，图像处理的第一步就是模糊图片，随着拍摄设备和存储设备的进步，图片的清晰度也在不断的提高，对于人来说，要识别图片中的某些元素，比如一个人，一个足球，一个杯子，那图片的清晰度越高越好，但计算机和人类完全不一样，清晰度越高，意味着细节越多，识别的难度就越大，因此，要让计算机能够准确的处理图像，模糊必不可少。

opencv一共提供了5中模糊方式，主要用于降低噪声和分辨率。

## 简单模糊和方框滤波

```c++
void blur( InputArray src, 
           OutputArray dst,
           Size ksize, 
           Point anchor = Point(-1,-1),
           int borderType = BORDER_DEFAULT )
```
参数src是输入图片

参数dst是模糊后的结果

参数ksize是模糊计算的核的大小，稍后详细结束

参数anchor用于表示核与图像的对齐方式，通常使用默认值

参数borderType用于确定图片的边界类型，通常使用默认值

接下来通过一段代码看下blur()是如何模糊图片的
```c++
int main{
    //构建大小为11x11的图片，全部元素都为0
    cv::Mat mat_src = cv::Mat::zeros(cv::Size(11, 11), CV_8UC1);
    //将图片中坐标为(6,6)的元素设为100
	mat_src.at<uchar>(6, 6) = 100;
    //mat_src.at<uchar>(6, 7) = 50;

    cv::Mat mat_dst;
	cv::blur(mat_src, mat_dst, cv::Size(3, 3));

    std::cout << mat_src;
	std::cout << std::endl;
	std::cout << "----" << std::endl;
	std::cout << mat_dst;
}
```
输出结果为

![图1](https://jxf2008-1302581379.cos.ap-nanjing.myqcloud.com/github_blog/opencv/blur_1.png)

从输出结果可以看出，源图片中一个元素为100，而模糊函数设置的核（既参数ksize）为3x3，简单模糊就是把这个以元素为中心，3x3为大小的元素全部设为100 / （3x3），也就是说，简单模糊是把核内的元素全部置为平均值。

接下来把坐标（6，7）的元素设为50（上面代码中注释掉的那行，现在取消注释），在观察下结果，现在有两个元素其值分别为100核50，那么这两个元素的核平局值为100/9=11.11,50、9=5.55，以下是代码再次运行的结果

![图2](https://jxf2008-1302581379.cos.ap-nanjing.myqcloud.com/github_blog/opencv/blur_2.png)

从结果上可以看出，简单模糊是把某个元素在的核的全部元素值为平均值，如果一个元素可属于不同的核，则该元素的值为全部核计算完成后的和

最后只将（6，6）的元素设为100，但把核的大小设为（5，5），运行结果为

![图3](https://jxf2008-1302581379.cos.ap-nanjing.myqcloud.com/github_blog/opencv/blur_3.png)

```c++
void boxFilter( InputArray src, 
                OutputArray dst, 
                int ddepth,
                Size ksize, 
                Point anchor = Point(-1,-1),
                bool normalize = true,
                int borderType = BORDER_DEFAULT )
```
boxFilter()为方框滤波，该函数模糊计算的算法和简单滤波一样，但多了一个参数ddepth,该参数用于设置输出图片的深度，如果该值设为-1，则输出结果和源图片的深度一致

## 中值滤波

中值滤波是将每个元素替换为围绕这个像素矩形领域内的中值（注意不是平均值），该函数为
```c++
void medianBlur( InputArray src, OutputArray dst, int ksize )
```
这里同样用之前的示例代码，之前使用的图片其（6，6）的元素设为100，而这里为了演示中值滤波，在图内添加一个3x3的非0区域，生成代码如下
```c++
int v = 1;
for (int i = 0; i < 3; ++i) {
	for (int j = 0; j < 3; ++j) {
		mat_src.at<uchar>(i + 5, j + 5) = v;
		++v;
	}
}

cv::medianBlur(mat_src, mat_dst, 3);
```
代码运行结果为

![图4](https://jxf2008-1302581379.cos.ap-nanjing.myqcloud.com/github_blog/opencv/blur_4.png)

解释下，原始图中，值为1的元素，以该元素为核心的3x3核，总计有9个元素，安从小到大排列为{0,0,0,0,0,1,2,3,4}，取中间的值为0，同理原始图中为2的元素，以该元素为核心3x3的核，总计9个元素，安从小到大为{0，0，0，1，2，3，4，5，6}，取中值为2。这里看出中值是核内元素安从小到大排序后中间的元素，而不是平均值。
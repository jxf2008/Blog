在很多视频的处理中，经常需要追踪某个物体在这段视频中的变化，很多时候追踪这个物体全部特征比较困难，但如果只追踪这个物体的一些关键的点，就会比较简单。

比如海洋中生活着很多种章鱼，而章鱼有个特性会经常改变自己的形状，很多章鱼都会把自己的身体变扁或者变细，以钻进一些细小的石缝内。对于生物学家来说，要确定章鱼的大小就比较困难了，后来生物学家发现了一个规律，章鱼虽然经常改变自己身体的大小和形状，但章鱼两个眼睛的距离确实比较恒定的，因此生物学家经常把章鱼两个眼睛之间的距离作为章鱼体型大小的数据。

回到编程来，如果有段有关章鱼的纪录片视频，现在需要分析这些章鱼在视频中的位置，行动习惯等等，那么追踪章鱼的两个眼睛比追踪章鱼的整体要简单许多。

## 角点与亚像素点

对于一个物体的关键点来说，根据不同的需求有不同的算法来查找，不同的算法查找出来的关键点也有所不同，opencv提供goodFeaturesToTrack()来查找关键点，定义如下
```c++
void goodFeaturesToTrack(InputArray image, 
                         OutputArray corners,
                        int maxCorners, 
                        double qualityLevel, 
                        double minDistance,
                        InputArray mask = noArray(), 
                        int blockSize = 3,        
                        bool useHarrisDetector = false, 
                        double k = 0.04 );
```
参数image是查找的目标图片，该图片必须是8位或者32位的单通道图片

参数corners是查询的结果，通常使用std::vector < cv::Point2f >。

参数maxCorners是查询关键点的最大个数

参数qualityLevel用于设置关键点的返回质量，通常取值[0.01,0.1]

参数minDistance用于设置关键点之间的距离，当查找到一个关键点时，便不在该范围内再寻找

参数mask为掩码

参数blockSize用于表示查询关键点时需要考虑的区域大小，对于高精度图片，这个值可以适当调大

参数useHarrisDetector用于设置查询关键点的算法，默认使用哈尔角点算法，用此算法查找到的关键点也称为角点，如果该值设为true，则使用托马斯算法

参数k只在使用哈尔角点算法时有效，一般使用默认值即可

goodFeaturesToTrack()可以有效的寻找图片中的关键点，但这里有个问题，该函数查找的是某个元素，但很多物体的特征点不会位于一个元素内，比如之前提过的章鱼的眼睛，在一幅图片内，章鱼的眼睛可能占据多个元素的位置，假如章鱼的眼睛占据16个元素，既一个4x4的矩阵，此时需要眼睛中心作为关键点，那这个关键点就会位于两个元素的中间。为了解决这个问题，opencv提供了亚元素角点的概念，既首先寻找关键区域的角点，然后以角点和周围的元素进行一定的计算，进而确定关键点，通过这种方式确定的关键点被称为亚像素角点，opencv提供了cornerSubPix()函数来实现该功能
```c++
void cornerSubPix(InputArray image, 
                  InputOutputArray corners,
                  Size winSize, 
                  Size zeroZone,
                  TermCriteria criteria );
```
参数image是目标图片

参数corners是查询到的全部亚像素角点

参数winSize是要求计算的区域，一个亚像素角点会在该区域内计算得出

参数zeroZone用于标注忽略的区域，该区域通常比winSize小一些，如果指定了该值，计算时先查找到角点，然后忽略角点附近区域的元素（大小为zeroZone）。如果不想由此步骤，传入Size(-1,-1)即可

最后的TermCriteria是一个稍显复杂的类，定义如下
```c++
class TermCriteria{
public:
    enum Type{
        COUNT=1, 
        MAX_ITER=COUNT, 
        EPS=2 
    };

    TermCriteria();
    TermCriteria(int type, int maxCount, double epsilon);

    inline bool isValid() const{
        const bool isCount = (type & COUNT) && maxCount > 0;
        const bool isEps = (type & EPS) && !cvIsNaN(epsilon);
        return isCount || isEps;
    }

    int type; 
    int maxCount; 
    double epsilon; 
};
```
这个类在opencv的很多函数里都会作为参数使用，该类主要用于设置算法的迭代次数和精度。

类成员type的值为枚举值，既类内枚举Type,该值用于设置，该类是用于限制迭代次数还是精度，或者同时限定

类成员maxCount用于设置迭代次数

参数epsilon用于设置算法的精度

## 光流和金字塔算法

对于一段视频来说，如果要分析一个物体持续的变换，就需要逐帧分析。而光流便是指在连续的两帧，每个对应位置的变化。光流分为稠密和稀疏，稠密光流指的是分析两帧图片的全部像素，这导致计算量会非常大，而稀疏光流则仅分析关注的部分的元素。


## 数组的不足

C++中内置的数组，用于处理大量数据，但内置的数组在使用时存在一个非常棘手的问题。数组在定义时就需要确定大小，也就是数组包含元素的个数，一但定义就无法更改，而实际情况在需要更改元素个数的情况比比皆是，大多数时候，需要在一组数据中插入，删除若干个元素，为此往往需要重新定义数组并复制，这种方法在有点时候会造成巨大的开销。

在C中，处理类似的情况一般使用链表，列如如果处理学生信息相关的数据时，可以使用一个双向链表，节点结构类似
```c++
struc Student{
    Student*  prev;
    char*     name;
    int       age;
    Student*  next;
};
```
然后提供一些列函数来处理链表的添，改，删等操作，而以C++的观观念来看这个问题，双向链表虽然比数组的功能更加强大，但任然有两个问题，首先，如果你自己实现一个双向链表，你会发现即使你小心翼翼，但任然有很多犯错的机会<sup>引1</sup>,其次，双向链表缺乏对泛型的支持，你为了处理学生信息花大力气实现了一个双向链表，但你又很快需要处理学生喜欢的全部电影的数据，于是你不得不立刻实现一个Film的双向链表。。。。。

为此，针对上述两个问题，可以使用C++的方式，首先将链表封装为一个类MList(即My List,区别于标准库里的std::list),其次，使用模板类来实现MList,使得MList可以支持泛型。

对于MList，需要对双向链表做一个少许的改动，通常的双向链表设计，是将第一个节点的prev指针设为null,将最后一个节点的next设为null,这样就可以判断链表的Head和tail。基本结构类似下图：

![](https://jxf2008-1302581379.cos.ap-nanjing.myqcloud.com/github_blog/STL/LIST1.png)

而MList则增加一个空的节点，该节点的value值为null,prev指针指向链表的最后一个节点，next指针指向链表的第一个节点，同理，链表的第一个节点的prev和最后一个节点的next指针均指向该空节点。类似下图：

![](https://jxf2008-1302581379.cos.ap-nanjing.myqcloud.com/github_blog/STL/LIST2.png)

这种设计一个主要好处就是只需要记录一个节点，也就是这个空值的节点，就可以定位整个链表中所有节点。下面是初步实现

```c++
```